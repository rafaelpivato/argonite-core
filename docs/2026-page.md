# Argonite Naming Update: `Ui*` → `Page*`

**Status:** Frozen  
**Scope:** Runtime & Entry naming  
**Impact:** Semantic clarification only (no behavioral change)

---

## Summary

This document explains and formalizes the decision to replace the `UiRuntime` / `UiEntry` naming with:

- **`PageRuntime`**
- **`PageEntry`**

This change improves alignment with:
- Chrome’s actual execution model
- Argonite’s runtime-first philosophy
- Clear separation between *runtime hosts* and *UI abstractions*

No API or architectural behavior is altered.  
This is a **naming and mental-model correction**.

---

## The Core Problem with `Ui*`

The term **UI** is semantically overloaded.

In practice, `UiRuntime` and `UiEntry` were being used to represent:
- extension popup pages
- options pages
- devtools panels
- other extension HTML documents

However, **“UI” suggests a view layer**, components, or framework concerns
(React, Vue, rendering, composition), which is **not** what these constructs model.

In Argonite:
- Entries are *runtime entry points*
- Runtimes are *execution hosts*
- UI frameworks are **out of scope**

The name `Ui*` compressed too many ideas into a UI-shaped word.

---

## Chrome’s Actual Mental Model

Chrome does **not** define a generic “UI context”.

It defines **extension pages**:

- `action.default_popup` → HTML page
- `options_page` → HTML page
- devtools panels → HTML page
- any extension UI → HTML page with extension privileges

All of these share:
- a DOM
- a JavaScript execution environment
- access to `chrome.*`
- a page lifecycle (load / unload)

> **“Page” is the native Chrome concept.  
> “UI” is an abstraction layered on top.**

---

## Why `PageRuntime` Is the Correct Name

Argonite already models runtime hosts explicitly:

- `BackgroundRuntime` — service worker context
- `ContentRuntime` — injected page script context

Introducing:

- **`PageRuntime` — extension HTML page context**

creates a clean, symmetric runtime model:

```
BackgroundRuntime  → system authority
ContentRuntime     → injected client
PageRuntime        → extension page client
```

`PageRuntime` communicates:
- *where* code runs
- not *what* it renders
- not *how* it is implemented

This aligns perfectly with Argonite’s runtime-only scope.

---

## Why `PageEntry` Is Semantically Precise

An **Entry** in Argonite is:
- a runtime entry point
- a wiring / mounting unit
- not a UI abstraction
- not a component

`PageEntry` means:

> “An entry that executes inside a PageRuntime.”

Nothing more, nothing less.

It avoids implying:
- UI frameworks
- visual hierarchy
- rendering concerns
- component ownership

---

## Subclassing Becomes Obvious

Using `PageEntry` as a base enables clear, self-documenting specialization:

```ts
abstract class PageEntry { … }

class PopupEntry extends PageEntry { … }
class OptionsEntry extends PageEntry { … }
class DevtoolsPanelEntry extends PageEntry { … }
class ExtensionPageEntry extends PageEntry { … }
```

Each subclass maps directly to a known Chrome concept.

No glossary is required.

---

## Consistency with Argonite’s Architecture

This naming aligns with the same principles that motivated:
- the introduction of **Sentinels**
- the separation of **Capabilities** and **Services**
- explicit runtime ownership and authority

If a name sounds like a *UI abstraction*, it is likely wrong.

Entries and runtimes are **system wiring constructs**, not UI concepts.

---

## What Changed

| Before | After |
|------|------|
| `UiRuntime` | `PageRuntime` |
| `UiEntry` | `PageEntry` |

Subclasses (`PopupEntry`, `OptionsEntry`, etc.) remain valid and encouraged.

---

## What Did *Not* Change

- Runtime behavior
- Lifecycle semantics
- Entry responsibilities
- UI framework integrations (React/Vue)
- Public developer capabilities

This is a **semantic correction**, not a refactor mandate.

---

## Final Decision (Frozen)

- ✅ Use `PageRuntime` instead of `UiRuntime`
- ✅ Use `PageEntry` instead of `UiEntry`
- ✅ Specialize via subclasses (`PopupEntry`, `OptionsEntry`, …)
- ❌ Avoid `Ui*` as base naming

This naming better teaches Argonite’s architecture by itself and
keeps the framework aligned with Chrome’s real execution model.

---

**End of document**
